# ASSIGNMENT 3 - Virtual Machines and Debuggers
Software Construction HS23, University of Zurich, Supervision Prof. Dr. Bacchelli

Authors:
* Ece Zeynep Asirim (ecezeynep.asirim@uzh.ch)
* Mara Miruna Bucur (maramiruna.bucur@uzh.ch)
* Smail Alijagic (smail.alijagic@uzh.ch)
***

To integrate the new section into the existing Table of Contents, you can add the following entries:

# Table of Contents

### **[Introduction](#introduction)**

### **[File Structure](#filestructure)**

### **[Unit Testing](#unittesting)**
* [Usage](#usageTask1)
* [Testing the Assembler](#testassembler)
    * [Assembly Programs and Manual VM Output Calculations](#assemblyprog)
    * [Assembler Output](#assembleroutput)
* [Testing the Virtual Machine](#testvm)
    * [Virtual Machine Output](#vmoutput)
* [Introducing Errors](#introerror)
    * [Out-of-memory Error Test](#oomerror)
    * [Instruction-not-found Error Test](#inferror)
* [Reporting Test Coverage](#testcov)

### **[Disassembler for Virtual Machine](#disassembler)**
* [Overview on Implementation](#overview)
* [Usage](#usageTask2)
* [Components](#comp)
    * [Disassembler Class](#classdisassembler)
    * [Main Function](#mainfunc)
* [Error Handling](#errorhandl)
* [Testing of Disassembler](#testdisassembler)

### **[Implementing New Features and Problems](#newfeatures)**
* [Increment and Decrement](#incdec)
* [Swap Values](#swap)
* [Reversing Array in Place](#reversearray)

### **[New Features for Debugger](#debuggerfeatures)**
* [Memory Range Display](#memoryrange)
* [Breakpoints Management](#breakpoints)
* [Command Completion](#commandcompletion)
* [Watchpoints](#watchpoints)
***

<div id="introduction"/>

# Introduction

---
This project aims to provide an in-depth exploration and hands-on experience with Virtual Machines and Debuggers. It also incorporates the practical use of the Python testing framework _pytest_. 

<div id="unittesting"/>

# File Structure

---

Files marked with **-->** do not need to be present. They will be new created or overwritten (if already in the folder). All other files must be present!

```
debugger/
    architecture.py
    assembler.py
    count_up.as
    count_up.mx
    test_watchpoint.as
    test_watchpoint.mx
    vm_base.py
    vm_break.py
    vm_extend.py
    vm_step.py

exercise_1/
    ex1_architecture.py
    ex1_arrays.py
    ex1_assembler.py
    ex1_test.py
    ex1_test_1.as
    ex1_test_1.mx               --> generated during testing
    ex1_test_1.out              --> generated during testing
    ex1_test_1exp.mx
    ex1_test_1exp.out
    ex1_test_2.as
    ex1_test_2.mx               --> generated during testing
    ex1_test_2.out              --> generated during testing
    ex1_test_2exp.mx
    ex1_test_2exp.out
    ex1_test_3.as
    ex1_test_3.mx               --> generated during testing
    ex1_test_3.out              --> generated during testing
    ex1_test_3exp.mx
    ex1_test_3exp.out
    ex1_test_4.as
    ex1_test_4.mx               --> generated during testing
    ex1_test_4.out              --> generated during testing
    ex1_test_4exp.mx
    ex1_test_4exp.out
    ex1_test_5c1.as
    ex1_test_6c2.as
    ex1_vm.py
    
excercise_2/
    ex2_architecture.py
    ex2_assembler.py
    ex2_diassembler.py
    ex2_disassembler_test.py
    ex2_input_file.mx
    ex2_output_file.as          --> generated by calling
    ex2_test1.as
    ex2_test1.mx                --> generated during testing
    ex2_test1_disassembled.as   --> generated during testing
    ex2_test2.as
    ex2_test2.mx                --> generated during testing
    ex2_test2_disassembled.as   --> generated during testing

exercise_3/
    example_3_1.as
    example_3_2.as
    example_3_3.as
    example_3_3_odd_array.as

vm/
    architecture.py
    arrays.py
    assembler.py
    count_up.as
    count_up.mx
    vm.py

README.md
```



# Unit Testing

---

## Usage
Inside the final directory ```usr/.../exercise_1``` entering ```pytest``` will run all tests automatically. Pytest also offers some other functionalities (described later).

<div id="testassembler"/>

## Testing the Assembler

<div id="assemblyprog"/>

In order to test the assembler, first an assembly programme needs to be defined. Manually the assembly file is translated to a .mx file. Now the test assembles the assembly files and check if the new created .mx file is identical to the manually created .mx file.

### Assembly Programs and Manual VM Output Calculations
Below, each assembly programs are described in terms of their purpose. Their manual calculations are also presented, which are based on the opcode mappings specified in _ex1_architecture.py_.  

**_ex1_test_1.as_**  
```
hlt
```
_Purpose:_  
This is the simplest possible program, containing only the halt instruction. _hlt_ Instructs the machine to stop executing instructions. It tests the VM's ability to recognize and execute the halt instruction, which typically stops the execution.
_Manual Calculation:_ 
* hlt corresponds to opcode 0x1.

**_ex1_test_2.as_**  
```
ldc R0 0
ldc R1 3  
loop:  
prr R0  
ldc R2 1  
add R0 R2  
cpy R2 R1  
sub R2 R0  
bne R2 @loop  
hlt
```
_Purpose:_ 
This assemly program is a loop that increments a counter and prints its value. The loop increments a counter and prints its value until it reaches 3. The process is as follows:
    ldc R0 0 loads 0 into register R0.
    ldc R1 3 loads 3 into register R1.
    ldc R2 1 (inside the loop) loads 1 into register R2.
    prr R0 prints the current value in R0.
    add R0 R2 adds R0 and R2, storing the result in R0.
    cpy R2 R1 copies the value in R1 to R2.
    sub R2 R0 subtracts R0 from R2, storing the result in R2.
    bne R2 @loop causes the program to jump back to the loop label if R2's value is not 0.
    hlt terminates the program execution.

_Manual Calculation:_ 
* ldc R0 0: Opcode 0x2, Register R0 (0), Value 0 → 0x20000
* ldc R1 3: Opcode 0x2, Register R1 (1), Value 3 → 0x20103
* prr R0: Opcode 0xA, Register R0 (0) → 0xA00
* ldc R2 1: Opcode 0x2, Register R2 (2), Value 1 → 0x20201
* add R0 R2: Opcode 0x6, Registers R0 (0) and R2 (2) → 0x60002
* cpy R2 R1: Opcode 0x4, Registers R2 (2) and R1 (1) → 0x40201
* sub R2 R0: Opcode 0x7, Registers R2 (2) and R0 (0) → 0x70200
* bne R2 @loop: Opcode 0x9, Register R2 (2), Address of loop (assumed 2) → 0x90202
* hlt: Opcode 0x1

**_ex1_test_3.as_**
```
ldc R0 1
ldc R1 0
loop:
ldc R2 1
sub R0 R1
add R1 R2
beq R0 @loop
hlt
```
_Purpose:_ 
This program involves subtraction and a conditional branch. It initializes two registers and enters a loop. Within the loop, it subtracts the values of two registers, increments one, and continues the loop until a condition is met (when the value in R0 becomes equal to zero). The process is as follows:
    ldc R0 1 loads the value 1 into register R0.
    ldc R1 0 loads the value 0 into register R1.
    ldc R2 1 loads the value 1 into register R2, used within the loop.
    sub R0 R1 subtracts the value in R1 from R0 and stores the result back in R0.
    add R1 R2 adds the values in R1 and R2 and stores the result in R1.
    beq R0 @loop checks if the value in R0 is equal to 0. If so, it branches (jumps) back to the loop label, creating a loop.
    hlt stops the program execution.

_Manual Calculation:_ 
* ldc R0 1: Opcode 0x2, Register R0 (0), Value 1 → 0x20001
* ldc R1 0: Opcode 0x2, Register R1 (1), Value 0 → 0x20100
* ldc R2 1: Opcode 0x2, Register R2 (2), Value 1 → 0x20201
* sub R0 R1: Opcode 0x7, Registers R0 (0) and R1 (1) → 0x70001
* add R1 R2: Opcode 0x6, Registers R1 (1) and R2 (2) → 0x60102
* beq R0 @loop: Opcode 0x8, Register R0 (0), Address of @loop (assumed 2) → 0x80002
* hlt: Opcode 0x1

**_ex1_test_4.as_**
```
ldc R0 13
ldr R1 R0
ldc R2 2
prm R0
prm R1
str R0 R2
prm R0
prm R2
hlt
```
_Purpose:_   
This program tests memory-related operations. It loads a value into a register, retrieves a value from a memory address, and performs store and print operations.The process is as follows:  
    ldc R0 13 loads the value 13 into register R0.  
    ldc R2 2 loads the value 2 into register R2.  
    ldr R1 R0 loads the value from the memory address pointed to by R0 into R1.  
    prm R0 and prm R1 print the values in R0 and R1, respectively.  
    str R0 R2 stores the value in R0 into the memory address pointed to by R2.  
    hlt stops the program execution.  

_Manual Calculation:_  
* ldc R0 13: Opcode for ldc: 0x2, Register R0 (0), Value 13 → 0x2000D (Hexadecimal for 13 is D)
* ldr R1 R0: Opcode for ldr: 0x3, Registers R1 (1), R0 (0) → 0x30001
* ldc R2 2: Opcode 0x2, Register R2 (2), Value 2 → 0x20202
* prm R0: Opcode 0xB, Register R0 (0) → 0xB00
* prm R1: Opcode 0xB, Register R1 (1) → 0xB01
* str R0 R2: Opcode 0x5, Registers R0 (0) and R2 (2) → 0x50002
* prm R0 (second occurrence): Opcode 0xB, Register R0 (0) → 0xB00
* prm R2: Opcode 0xB, Register R2 (2) → 0xB02
* hlt: Opcode 0x1

<div id="assembleroutput"/>

### Assembler Output
When an assembly program is run through the assembler, an .mx file is produced for each .as file consisting of the machine code representation of each assembly instruction in the program.  
Below are the machine code output produced by the Assembler from the corresponding .as file.

**_ex1_test_1.mx:_**
```
000001
```
**_ex1_test_2.mx:_**
```
000002
030102
00000a
010202
020006
010204
000207
020209
000001
```
**_ex1_test_3.mx:_**
```
010002
000102
010202
010007
020106
020008
000001
```
**_ex1_test_4.mx:_**
```
0d0002
000103
020202
00000b
00010b
020005
00000b
00020b
000001
```
To compare the results of our manual calculations with the actual Assembler output, manual calculations of each .as file is written in an "...exp.mx" file (for instance, _ex1_test_1exp.mx_). Our manual calculations are consistent with the content of the .mx file of all assembly programs.  

<div id="testvm"/>

## Testing the Virtual Machine

In order to test the virtual machine, the previous created .mx files are run through the virtual machine. As for the assembler a manually created .out file will be compared to the .out file that was created with the virtual machine. Only if both are identical we can guarantee (to a certain extent) that the virtual machine runs well.

This process is executed with the assumption that the Assembler is correct. Without this assumption, testing would become significantly more complex. Any errors in the output could be due to issues with either the Assembler or the VM. Hence, this would require a dual-layered approach to debugging, where both the translation of assembly code to machine code (by the Assembler) and the execution of that machine code (by the VM) must be analyzed for errors.

<div id="vmoutput"/>

### Virtual Machine Output
Below, our thought process behind  expected output of running each .mx file through the VM is presented.

**_ex1_test_1exp.out_**
1. Register state: The VM initializes all registers to 0. Since number of registers (NUM_REG) is defined as 4 in _ex1_architecture.py_, there will be a line for each register showing its initial state:
```
R000000 = 000000
R000001 = 000000
R000002 = 000000
R000003 = 000000
```
2. Memory content: The first line of the memory will have the `hlt` instruction (0x1), and the rest will be zeros. The memory dump will show several lines, but only the first line will have non-zero content (the hlt instruction). Since the hlt instruction halts the VM, there are no further operations or changes in the state of the VM. This means the registers and memory remain unchanged after the execution of the hlt instruction.  
The rest of the lines will display zeros up to the length determined by COLUMNS, which is set to 4 in _ex1_vm.py_, and size of memory RAM_LEN, which is set to 256 in _ex1_architecture.py_.
```
000000:   000001  000000  000000  000000
```

**_ex1_test_2exp.out_**
1. Register state: All registers are initialized to 0.  
After the execution, register R0 ends with the value 3, at which point the loop terminates.
R1 remains 3 throughout.
R2 will be 0 after the last subtraction (sub R2 R0).
```
R000000 = 000003
R000001 = 000003
R000002 = 000000
R000003 = 000000
```
2. Memory content:
000000, 000004, 000008 are hexadecimal numbers representing the location in memory (memory addresses) where each instruction is stored.
Since COLUMNS is defined as 4 in the VM, there will be 4 machine code instructions per memory address line in  the memory dump (how this is shown is determined inside the _show_ method in _ex1_vm.py_), followed by zero for unused or uninitializeds memory locations.
```
000000:   000002  030102  00000a  010202 [Machine code for ldc R0 0, ldc R1 3, prr R0, ldc R2 1 in order]
000004:   020006  010204  000207  020209 [Machine code for add R0 R2, ccpy R2 R1, sub R2 R0, bne R2 @loop in order]
000008:   000001  000000  000000  000000 [Machine code for hlt, the rest is unused memory locations]
```

**_ex1_test_3exp.out_**
1. Register State:
R0 will eventually be 0 (after subtraction in the loop).
R1 will be incremented in each iteration and match R0 at the end.
R2 is used for temporary calculations and will be 1 at the end.
```
R000000 = 000001
R000001 = 000001
R000002 = 000001
R000003 = 000000
```
2. Memory Content:
Contains machine code corresponding to the instructions in _ex1_test_3.as_ (plus zeros to complete the column).
```
000000:   010002  000102  010202  010007  # Machine code for ldc R0 1, ldc R1 0, ldc R2 1, sub R0 R1 in order
000004:   020106  020008  000001  000000  # Machine code for add R1 R2, beq R0 @loop, hlt, unused memory location in order
```
**_ex1_test_4exp.out_**
1. Register State:
R0 will be 13 after loading, then its value will be stored in memory, which is _0d_ in hexadecimal.
R1 will try to load the value from memory address 13, which might be 0 if not initialized.
R2 will be set to 2.
R3 will be 0, since it isn't used in the program.
```
R000000 = 00000d
R000001 = 000000
R000002 = 000002
R000003 = 000000
```

2. Memory Content:
Contains machine code corresponding to the instructions in _ex1_test_4.as_.
```
000000:   0d0002  000103  00000d  00000b  # Machine code for ldc R0 13, ldr R1 R0, ldc R2 2, prm R0 in order
000004:   00010b  020005  00000b  00020b  # Machine code for prm R1, str R0 R2, prm R0, prm R2 in order
000008:   000001  000000  000000  000000  # Machine code for hlt, the rest is unused memory locations
```
<div id="introerror"/>

## Introducing Errors

<div id="oomerror"/>

### Out-of-memory Error Test
The goal of this test is to ensure that the VM or Assembler properly handles situations where an array allocation request exceeds the available memory (RAM_LEN).
**_ex1_test_5c1.as_** 
```
ldc R0 0
ldc R1 300
ldc R2 @array
loop:
str R0 R2
ldc R3 1
add R0 R3
add R2 R3
cpy R3 R1
sub R3 R0
bne R3 @loop
hlt
.data
array: 300
```
Implements a loop that attempts to store a value in memory repeatedly until a condition is met. It's using the ldc instruction to load constants and the str instruction to store values in memory. The key factor here is the array declaration, which reserves 300 units of memory space. However, the code in the loop is designed to run indefinitely as it lacks a termination condition.As a result, this code will keep attempting to store values in memory (str R0 R2) without ever stopping, effectively causing the virtual machine to exhaust its memory resources. When this file is processed by the assembler (specifically the _DataAllocator_ class in _ex1_arrays.py_), it should calculate the total memory requirement for the array.

<div id="inferror"/>

### Instruction-not-found Error Test
This test aims to check whether the VM properly handles a situation where an .mx file contains an unknown or undefined instruction.
**_ex1_test_6c1.as_** 
```
ldd R0 1
hlt
```
The assembly code attempts to use an instruction labeled as ldd R0 1. However, this instruction is not part of the virtual machine's defined instruction set. The virtual machine doesn't recognize ldd as a valid instruction. When this file is processed by the assembler, it will trigger an instruction-not-found error.

<div id="testcov"/>

### Reporting Test Coverage

Using coverage it is possible how much percent of the code is covered by our tests. The higher the cover rate the more features of a code have been tested. The module counts which lines of code were run and which not. For more detailed description visit this link: https://medium.com/@sumanrbt1997/code-coverage-with-pytest-1f72653b0bf2.

Creating such a report is very easy. First move to the directory where our test file is saved ```Usr/.../excercise_1``` instead of calling ```pytest``` as previously we now first call ```coverage run -m pytest``` (this runs all our tests and saves the result). Calling ```coverage report -m``` from the terminal will now create a report from the previously ran tests.

Here you can see the generated report for testing exercise 1
```
Name                  Stmts   Miss  Cover   Missing
---------------------------------------------------
ex1_architecture.py       6      0   100%
ex1_arrays.py            40      3    92%   49-50, 56
ex1_assembler.py         80     15    81%   7-16, 112-119, 122
ex1_test.py              57      4    93%   73-75, 90-92
ex1_vm.py                74     12    84%   80, 91, 96-105, 109
---------------------------------------------------
TOTAL                   257     34    87%
```
<div id="disassembler"/>


# Disassembler for Virtual Machine

---

<div id="overview"/>

### Overview on implementation
We designed a disassembler ```disassembler.py``` in Python that is able to convert virtual machine code, which is in hexadecimal format, back to the original assembly language. The code engages operations such as parsing, mapping and machine code translations by using Pyhton built-in capabilities for string manipulation, error handling and file operation. It is important to highlight that not every assembly file can be successfuly disassembled. E.g.:
```
ldc R0 3  # loop iterations
ldc R1 1  # temp variable
loop:
prr R0
sub R0 R1
bne R0 @loop
hlt
```
The issue with this program is that ```@loop``` will be converted to 2 (it's line number) in the assembler. Disassembling the freshly created ```.mx``` file will create the following:
```
ldc R0 3  # loop iterations
ldc R1 1  # temp variable
loop:
prr R0
sub R0 R1
bne R0 2
hlt
```
Comparing the two assembly files return False since they are not the same. Therefore it is important to not use any @ but instead directly the numerical representation.

<div id="usage"/>

### Usage
The file ```dissasemble.py``` should be in the same directory with the provided ```architecture.py``` file that contains the OPS dictionary and other necessary configurations .

The disassembler is executed from the command line with the following syntax:
```
python disassemble.py [input_file.mx] [output_file.as]
```
This command takes a machine code file ```.mx``` as input and outputs the disassembled code into an assembly language file ```.as```.

#### Example Usage
For a `.mx` file containing:
```
030102
050102
000001
```
Run the script as follows:
```
python disassemble.py input.mx output.as
```
The `output.as` file will contain the assembly code:
```
ldc R0 1
ldc R1 2
hlt
```
<div id="comp"/>

### Components

<div id="classdisassembler"/>

#### Disassembler Class
The Disassembler class is the central part of the implementation and compriseses of implementations of the following functions:

- ```disassemble(self, lines)```: It is the main function of the class and it deals with processing the input lines of virtual machine code in two steps:
   * cleaning the input by removing comments and empty lines
   * translating each line into the correct assembly language instruction
   
- ```_compile(self, instruction)```: Very important function of the class which deals with how virtual machine instructions are interpreted and executed. It takes a single machine code instruction and converts it to the equivalent statement in assembly language. It does that by mapping operation codes (opcodes) from machine code to their corresponding assembly language in a few steps:

   1. **Tokenizing the Instruction**: The machine code instruction (which is initially a string like ```"00 01 11"```) is split into its three components: the opcode and its two arguments.

   2. **Reversing Token Order**: The tokens are reversed to align with the order expected in assembly language. For instance, ```"00 01 11"``` becomes ```["11", "01", "00"]```.

   3. **Opcode Mapping**: Each opcode in machine code corresponds to an assembly language command. This mapping is achieved using a dictionary (```reversed_ops```) created from the global ```OPS``` dictionary. This dictionary maps numeric opcodes (like ```1``` for ```"hlt"```) to their string command equivalents in assembly language.

   4. **Formatting the Assembly Instruction**: Depending on the format specified in the ```OPS``` dictionary for each operation (```"--"```, ```"r-"```, ```"rr"```, or ```"rv"```), the function formats the assembly instruction accordingly. For example:
   - A format of ```"--"``` means the operation takes no arguments (e.g., ```hlt```).
   - A format of ```"r-"``` indicates a single register argument (e.g., ```prr R0```).
   - Formats ```"rr"``` and ```"rv"``` denote operations with two arguments, which could be two registers or a register and a value, respectively (e.g., ```add R0 R1```, ```ldc R0 5```).

- ```_to_text(self, program)```: Converts hexadecimal strings into a more readable and processable format. This function is essential for preparing the raw input into a form that the ```_compile``` function can efficiently process.

- ```_get_lines(self, lines)```: Filters and prepares the input lines by removing extraneous elements like comments, ensuring that only executable code is fed into the disassembly process.

Certainly! Here's a revised description for the "Main Function" and "Error Handling" sections that uses straightforward language and provides more detailed explanations:

<div id="mainfunc"/>

#### Main Function
The script is designed for command line use, where it reads an input file, processes it, and writes the output to another file. It takes the following steps:

1. **Reading Input**: When you run the script, it first opens and reads the contents of the input file (a .mx file in this case).
   
2. **Disassembling Process**: The read content is then passed to the Disassembler class. This class handles the conversion of machine code from the input file into human-readable assembly instructions.

3. **Writing Output**: Finally, the script writes these assembly instructions into the output file specified by the user. This output file is where you can view the disassembled code.

<div id="errorhandl"/>

### Error Handling

1. **In the ```_compile``` Function** the error handling is done by checking for unknown operation codes and unsupported instruction formats. If an operation code that isn't defined in the OPS dictionary is encountered, it flags this as an error. Additionally, it verifies if the format of each instruction is correct and compatible with the predefined formats in OPS.

2. **Within the ```disassemble``` Function**: Each instruction is processed individually in a loop that contains a try-except block to handle exceptions that might arise during the compilation of instructions. This includes errors like invalid instruction formats or unrecognized operation codes. When such errors are detected, the script outputs detailed error messages to the standard error stream (`stderr`). These messages include the specific instruction that causes the issue and a description of the error to help the user identify issue. 

<div id="testdisassembler"/>

### Testing of Disassembler
Testing the disassembler was done using pytest. The test starts with an assembly file, this assembly file is run through the assembler and the assembled ```.mx``` file is disassembled into an assembly file. The original and new created assembly file are checked on equality. This test is only valid if we assume that the assembler runs correctly. Else it is very hard to say if the mistake comes from a buggy assembler or buggy disassembler.

<div id="newfeatures"/>

# Implementing New Features and Problems

---
<div id="incdec"/>

### Increment and Decrement
#### Usage
For the implementation, _architecture.py_ and _assembler.py_ in the vm/ directory. are modified. To showcase the functionality, the assembly program _example_3_1.as_ is written which runs on the terminal with the command:
```
python assembler.py example 3 1.as output 3 1.mx 
python vm.py output 3 1.mx -
```

In _architecture.py_, the OPS dictionary is modified to include the incremend and decrement instructions:
```
"inc": {"code": 0xC, "fmt": "r-"},  # Increase value at register by 1 R0 = R0 + 1
"dec": {"code": 0xD, "fmt": "r-"},  # Decrease value at register by 1 R0 = R0 - 1
```

In _assembler.py_, the _compile method is modified to handle these new instructions and their formats:
```
if fmt == "r-":
    return self._combine(self._reg(args[0]), code)
```
This code handles instructions with a single register operand (for instance _inc R0_ and _dec R1_) and combines the operation code with the register number.  

_example_3_1.as_ showcases the new functionality:
```
ldc R0 7
ldc R1 3
prr R0
inc R0
prr R0
prr R1
dec R1
prr R1
hlt
```
The assembly program loads values into registers, prints them, alters them using inc and dec, and then prints the altered values.

<div id="swap"/>

### Swap Values

#### Usage

For the implementation, _architecture.py_ and _assembler.py_ in the vm/ directory. are modified. To showcase the functionality, the assembly program _example_3_2.as_ is written which runs on the terminal with the command:
```
python assembler.py example 3 2.as output 3 2.mx 
python vm.py output 3 2.mx -
```

The OPS dictionary in _architecture.py_ is updated to include the new swap instruction:
```
"swp": {"code": 0xE, "fmt": "rr"}   # swap two registers R0 = R1 && R1 = R0
```

In _assembler.py_, the _compile method is updated to handle the swap instruction and its format:
```
elif fmt == "rr":
    return self._combine(self._reg(args[1]), self._reg(args[0]), code)
```
In Python this is done, only the values are swapped while the registers remain:
```
elif op == OPS["swp"]["code"]:  # swapping two registers
    temp = self.reg[arg0]  # store value R0 into temp
    self.reg[arg0] = self.reg[arg1]  # set value R0 = value R1 
    self.reg[arg1] = temp  # set value R1 = value R0
```

This code handles instructions with two register operands (for instance _swp R0 R1_) and combines the operation code with the register numbers.  
_example_3_2.as_ assembly program showcases the _swp_ instruction:
```
ldc R0 9
ldc R1 4
prr R0
prm R0
prr R1
prm R1
swp R0 R1
prr R0
prm R0
prr R1
prm R1
hlt
```
It loads values into two registers, prints their initial values, swaps them using swp, and prints the swapped values.

<div id="reversearray"/>

### Reversing Array in Place

#### Usage
```
python assembler.py example 3 3.as output 3 3.mx 
python vm.py output 3 3.mx -
```

The assembly program _example3_3.as_ reverses an array in place. It consists of the following steps:

1. Array initialization: The array is initialized with specific values.
2. Reversing: The program uses a loop to reverse the array in place.
3. Halting: Finally, the program halts.

Breakdown of the program is as follows:
```
ldc R0 0  # load 0 into R0 (used as a counter)
ldc R1 4  # load 4 into R1 (as length of the array)
ldc R2 @array  # load the base address of the array into R2

# fill the array with values from 0 to 3

loop1:
str R0 R2  # store the value in R0 at the address in R2
ldc R3 1  # load 1 into R3
add R0 R3  # increment R0 by 1
add R2 R3  # move to the next array element (increment the address in R2)
cpy R3 R1
sub R3 R0
bne R3 @loop1  # repeat loop until R0 reaches 4

# initialize pointers for reversal

ldc R1 @array  # load the address of the first array element into R1
dec R2  # decrement R2 to point to the last array element

# Loop to reverse the array

loop2:
ldr R0 R1  # load the value at the address in R1 into R0
ldr R3 R2  # load the value at the address in R2 into R3
swp R0 R3  # swap the values in R0 and R3
str R0 R1  # store the value in R0 back at the address in R1
str R3 R2  # store the value in R3 back at the address in R2
inc R1  # move to the next element from the start
dec R2  # move to the previous element from the end
cpy R3 R2
sub R3 R1
bge R3 @loop2  # continue looping until the pointers meet in the middle

hlt  # halt the program

.data
array: 10  # allocate space for 10 elements
```
* The program initializes the array with consecutive values starting from 0. The base address of the array and its length are loaded into registers.  
* It uses two pointers (R1 and R2) to traverse the array from both ends. These pointers are incremented and decremented respectively, swapping elements at their positions until they meet or cross.  
* The _swp_ instruction swaps the array elements being pointed to by R1 and R2.
* This program is not quite legal, because we modified _architecture.py_ and _vm.py_ by adding ```bge``` (branch greater equal 0). This way we can ensure that every array is reversed correctly.  

Alternatively, we have impemented the assembly program _example3_3_odd_array.as_ which does not use ```bge```:
```
# this program only works for arrays with odd number of elements

ldc R0 0
ldc R1 3
ldc R2 @array
loop1:
str R0 R2
ldc R3 1
add R0 R3
add R2 R3
cpy R3 R1
sub R3 R0
bne R3 @loop1

# first element
ldc R1 @array
# last element
dec R2

loop2:
ldr R0 R1
ldr R3 R2
swp R0 R3
str R0 R1
str R3 R2
inc R1
dec R2
cpy R3 R2
sub R3 R1
bne R3 @loop2

hlt
.data
array: 10
```
Here, ```bge``` is replaced with ```bne```, but this only works for arrays with an odd number of elements. Thereforee, a generalized solution seems to be a million dollar question.

# New features for Debugger

---
## Memory Range Display
This feature improves the debugger implementation by adding memory inspection capabilities which allow users to easy visualization of certain areas in the memory. The addition of this feature was achieved through changes in the `vm_extend.py` which consist of adjustments to the memory display functionality that is designed to interpret and respond to one or more address inputs.

- Relevant Code from ```vm_extend.py```:
  ```python
      def _do_memory(self, addr, *args):  # args[0] -> memory address as integer
        try:
            addr_args = [int(a) for a in args[0]]  # make sure only numeric values
            self.show(addr_args)
        except:
            self.show()
        return True
  ```
  - Relevant Code from ```vm_base.py```:
    ```python
    # Show memory
          try:
              assert 0 <= len(args[0]) <= 2, f"args is too long: args = {args}"
              if len(args[0]) == 1:
                  base = int(args[0][0])
                  self.write(f"{base:06x}:   {self.ram[base]:06x}")
              elif len(args[0]) == 2:
                  base = int(args[0][0])
                  limit = int(args[0][1]) if int(args[0][1]) <= top else top
                  total_add = limit - base
                  while base <= limit:
                      output = f"{base:06x}: "
                      for i in range(COLUMNS):
                          if total_add == 0:
                              continue
                          else:
                              output += f"  {self.ram[base + i]:06x}"
                              total_add -= 1
                      self.write(output)
                      base += COLUMNS
              else:
                  base = 0
                  while base <= top:
                      output = f"{base:06x}: "
                      for i in range(COLUMNS):
                          output += f"  {self.ram[base + i]:06x}"
                      self.write(output)
                      base += COLUMNS
    ```
    ```show()``` takes an additional parameter, which is the memory address as integer. Inside the ```try``` block the additional argument is checked and depending on the length, different actions are done. When no address is given, it must show the whole memory, one address given must show the memory at that specific address, two addresses given must show all the address in the range of the two addresses given. More than two addresses will raise an assert.

### Usage:
- **Single Address:** Use ```memory 1``` or ```m 1``` to display the value at a specific address.
- **Multiple Address:** For a range of memory addresses, use ```memory 1 2``` or ```m 1 2``` to display all values between those two addresses.


### Testing:
- This functionality can be tested by using ```memory 0``` for single address, ```memory 0 3``` for address range. Using any of the two statements must show memory on the terminal.

## Breakpoints Management
This feature is implemented through enhancing the class  ```VirtualMachineBreak``` defined in ```vm_break.py``` and allows to set breakpoints at the desired memory addresses and also to clear them, when needed, meaning complete control for the user. 

- Relevant Code in ```vm_break.py```:
  ```python
  def _do_add_breakpoint(self, addr):
      self.breaks[addr] = self.ram[addr]
      self.ram[addr] = OPS["brk"]["code"]
  ```
  Inside```vm_extend.py -> interact()```it is checked if a parameter is given, based on that either a breakpoint at a specific address will be set/cleared or at the current address. If ```break``` is used without an additional parameter, it will not enter elif but go to else, where then _do_add_breakpoint(self.ip) (where self.ip is the current position of the pointer, in the debugger it is the current line) is called. If it was called like this: ```break 3``` it would enter elif and call _do_add_breakpoint(3).

### Usage:
- **Set Breakpoint:** ```break 4``` or ```b 4``` to set a breakpoint at address ```4```.
- **Clear Breakpoint:** ```clear 4``` or ```c 4``` to remove a breakpoint at that address.

### Testing
- To ensure that setting breakpoints works well, one can set a breakpoint for any valid address (not out of range). After complete running the debugger, the disassembled code at the memory must show up on the terminal.
- For testing clearing breakpoints, one has to set a breakpoint, then clear it and run the debugger until it finishes. If the breakpoint was successfully removed, no disassembled code will show up on the terminal.

## Command Completion
This feature, implemented in the ```VirtualMachineExtend``` class constructor from ```vm_extend.py```, is designed to enhance the efficiency of the debbuger. It allows users to enter commands more quick by recognizing all possible partial user inputs for the commands and completing them.

- Relevant Code in ```interact(self, addr)```:
  ```python
  command_found = {key: value for key, value in self.handlers.items() if key.startswith(command_args[0])}  # command_args[0] can be m, mem, r, q, etc.
  ```
  ```interact()``` receives user input, validates and calls the according function. If the user input is not correct the user will be accordingly informed without raising an error (the user does not have to restart the program). 

### Usage:
- Short commands like ```m``` for ```memory``` or ```di``` for ```disassemble``` are recognized and executed as the full command.

### Testing
- To make sure that the command completion works well, the user can just use ```r``` instead of ```run``` or ```q``` instead of ```quit``` and check if it works the same.

## Watchpoints
This feature, integrated into the ```VirtualMachineBreak``` class in ```vm_break.py```, allows users to monitor specific memory addresses by halting the program when changes occur at any stage of the program. For this, a  monitoring system was implemented in order for the specified memory addresses to track any changes and to respond to them. Once a value was changed at a watchpoint, value inside the dictionary will be updated, meaning: if value at address 1 is 0 {1: "0"}, then changes to 1 the program will halt and update the dictionary {1: "1"}. When the value now changes back to 0, the program will be halted again and the dictionary gets updated to {1: "0"}.

- Relevant Code in ```vm_break.py```:
  ```python
  def _do_add_watchpoint(self, addr):
      self.watchpoints[addr] = self.ram[addr]  # key = addr, val = command from .mx file
  ```

### Usage:
- Set   a watchpoint with ```watchpoint 5``` or ```w 5``` to monitor changes at address ```5```.
- Clear a watchpoint with ```cw 5``` or ```c 5``` to stop the monitoring of changes at address ```5```.

### Testing
- We can test our watchpoint function, by setting a watchpoint to an address, where we know that the value will change. Then we can "run" our debugger. If the watchpoint function works well, then the program must halt at that specific address.